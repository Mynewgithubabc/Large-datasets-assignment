---
title: "Large datasets assignment"
output: html_document
date: "2024-02-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```






```{r, echo = FALSE}
#Clear the R environment: if anything from a previous session is here it clears the objects that were made before. 
rm(list = ls())

```

```{r, echo = FALSE} 
#installing and loading the required packages

# Check if Rcompadre package is installed
if (!requireNamespace("Rcompadre", quietly = TRUE)) {
  # If not installed, install it
  install.packages("Rcompadre")
}

# Check if tidyverse package is installed
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  # If not installed, install it
  install.packages("tidyverse")
}

if (!requireNamespace("popbio", quietly = TRUE)) {
  # If not installed, install it
  install.packages("popbio")
}

if (!requireNamespace("Rage", quietly = TRUE)) {
  # If not installed, install it
  install.packages("Rage")
}

if (!requireNamespace("ggplot2", quietly = TRUE)) {
  # If not installed, install it
  install.packages("ggplot2")
}

if (!requireNamespace("taxsizw", quietly = TRUE)) {
  # If not installed, install it
  install.packages("taxsizw")
}

if (!requireNamespace("dplyr", quietly = TRUE)) {
  # If not installed, install it
  install.packages("dplyr")
}

if (!requireNamespace("phytools", quietly = TRUE)) {
  # If not installed, install it
  install.packages("phytools")
}






# Load the libraries
library(Rcompadre)
library(tidyverse)
library("popbio")
library("Rage")
library(ggplot2)
library(taxize)
library(dplyr)
library(phytools)






```



```{r, echo = FALSE}


#Fetch the most recent database version from www.compadre-db.org with:
comadre <- cdb_fetch("comadre") 
#This function takes comadre from the website www.comadre-db.org. This website has two databases, comadre for animals and compadre for plants. I am telling it to fetch comadre, 

#The command 'dim' tells me the dimension of the database comadre
dim(comadre)


```


```{r, echo = FALSE}
#Exploring the metadata in COMADRE. Metadata is 'extra' information surrounding my data.
comadre@data

#Examining all the possible classes in the dataset
unique_classes <- unique(comadre@data$Class)
# Print the unique classes
print(unique_classes)

```


```{r}
##In order to establish relationships between generation time and conservation status, we need to ensure that statistical inferences only concern these and no otehr confounding variables. We therefore subset the data to allow us to draw fair comparisons.
#subsetting my data to only include reptiles, and to only include wild individuals, not captive individuals. The species will also not be constrained geographically. 
comadre1 <- subset(comadre,
                   # Consider only reptiles
                   Class == "Reptilia" & 
                  #studied under "control" (i.e. no treatment) conditions
                   MatrixTreatment == "Unmanipulated" &
                   #only from "W"ild populations
                   MatrixCaptivity == "W")     

#taking a subset of the whole dataset to make a smaller dataset to make a subset of only the species we are interested in. The criterium being imposed are:
#just reptiles, with no geographical constraint.
#Matrix treatement unmanipulated, ie representing the dynamics of huge populations under natural conditions.
# The last criterium states that they are only from wild populations. 

#ensuring that there are at least 10 unique species in this subset:

#Examining all the possible classes in the dataset I could choose from 
unique_species_reptilia <- unique(comadre1$Species)
# Print the unique classes
length(unique_species_reptilia)
#There are 28 unique species of reptiles in this dataset. 

#calculating the dimensions of my new subsetted comadre1: 
dim(comadre1)


```



```{r echo = FALSE}

#We will use the function cdb_flag() to add columns to the database which flag potential issues with these MPMs. This could include missing values, or MPMs that don’t meet assumptions necessary to calculate population growth rates.


#we cannot calculate population growth rate from any data that has NAs attached or is not ergodic. 
#ergodic means that there is statistical equivalence between mean values measured over time and mean values measured across space 

#we are therefore further subsetting the data based of of these requirements 
comadre_flags <- cdb_flag(comadre1)
comadre_sub <- subset(comadre_flags,
                      check_NA_A == FALSE &
                      check_ergodic == TRUE)

#Check size of subset data again:
dim(comadre_sub)
head(comadre_sub) 

```






QUESTION 1:



```{r}
#I am going to obtain population growth rates using the function "lambda" from the R package "popbio
#Using the function lapply (which applies a function to every element in a list), I will calculate the population growth rate (lambda) for each matrix.


comadre_sub$lambda <- unlist(lapply(matA(comadre_sub), popbio::lambda))
#from my subset that I have made from comadre I will call the MPM matA (the rate of growth of the pouplation) and apply the lambda function to it which will extract the growth rate. 

#Examining the distribution of population growth rates:
hist(comadre_sub$lambda, xlab= "Population growth rate", main = "Frequency distribution of Population growth rates")
abline(v = 1, col = 'red', lty = 2, lwd = 2) #this histogram shows the frequency distribution of population growth rates
#This line of code adds a verticle line at x = 1. 

#Populations change over time so if you want to consider a population over time the value of lambda changes, for example this might come from an abnormally good year. if you assume as many resources and that density dependence isnt important (hasnt reached carrying capacity) lambda would be higher than one. So unless you calculate lambda through a lot of matrix following populations over a long time this is problematic. 





```
The frequency distribution  of population growth rate centers around the value of 1. Most of the populations are not changing in size and are at demographic equilibrium. This is expected. If the conditions under which the matrix was parameterized do not change the population will remain stable. Density dependence causes population growth rates to tend to 1 since increasing beyond this value causes populations to exhaust their finite resources so population size decreases. There are some cases of larger population growth rate shown by the right skew of the distribution.  These may be outliers and may be recovering from a perturbation. 

Generating a histogram for distributions of generation time: 

```{r}
#To calculate generation time, we will use the R package "Rage"

#Again using the function lapply, we will now use the matrices U and F to find information about generation time 
#to calculate the generation time
comadre_sub$gen_T <- mapply(Rage::gen_time, matU(comadre_sub), matF(comadre_sub))
#In order to calculate generation time we must split the overall MPM up into sub matrices. We  require the sub matrix U (survival and growth) and F which includes sexual reproduction.

#Examining the distribution of generation times where generation time refers to the number of years from birth to reproduction.


hist(comadre_sub$gen_T, xlab = "Generation time (years)", main = "Frequency distribution of generation times")
#there is a higher frequency of populations with shorter generation times 

```

There is a higher frequency of populations with shorter generation times, especially between 0- 10 years. This is expected as populations with shorter generation times respond faster to environmental stress and evolve faster, and are therefore a positively selected feature. The distribution is right skewed as some reptiles have very long lifespans. 


QUESTION 2: Exploring whether there is a correlation between population growth rate and generation time: 



```{r, echo = FALSE}
#The data about population growth rate is: 
comadre_sub$lambda
#The data about generation time is: 
comadre_sub$gen_T


#The following code checks if there are NAs in lambda values and removes them. This is a conditional if loop that gets rid of nas that in this case isn't fulfilled as there are not any NAs in this dataset.
if (length(which(is.na(comadre_sub$lambda)))>0) {
  comadre_sub <- comadre_sub[-which(is.na(comadre_sub$lambda)),]
}

if (length(which(is.na(comadre_sub$gen_T)))>0) {
  comadre_sub <- comadre_sub[-which(is.na(comadre_sub$gen_T)),]
}


if (length(which(is.infinite(comadre_sub$gen_T)))>0) {
  comadre_sub <- comadre_sub[-which(is.infinite(comadre_sub$gen_T)),]
}

```


```{r}


#Creating a scatter plot of generation time against population growth rate 
ggplot(comadre_sub, aes(x = gen_T, y = lambda)) +
  geom_point() +  # Add points for each data point
  labs(x = "Generation Time", y = "Population Growth Rate") +  # Label axes
  ggtitle("Scatter Plot of Generation Time vs Population Growth Rate")  


# Extracting the variables
population_growth_rate <- comadre_sub$lambda
generation_time <- comadre_sub$gen_T

# Running correlation test
correlation_test_result <- cor.test(generation_time, population_growth_rate)

# Print the correlation test result
print(correlation_test_result)


```
The p value for my pearson’s correlation test is 0.2615. This value is greater than 0.05 therefore there is no statistically significant correlation between population growth rate and generation time. This is not expected. We would expect a correlation as shorter generation times should cause populations to increase faster since organisms with shorter generation times produce more offspring per unit of time. 
More correlation might have been expected if there was more variation seen in the population growth rates. However since population growth rate tends around 1, no correlation with generation time can be observed. 

QUESTION 3: 


```{r, message=FALSE, error=FALSE, warning=FALSE, echo = FALSE}
#Note that the object 'comadre_sub' contains multiple MPMs for each species. Sometimes these MPMs correspond to different years within the same population, or they may refer to different populations, or come from different publications or research groups. We will only sample one MPM per species:

#In the following line of code I will select the first entry of the whole of comadre_sub where ther is a new species using the command 'duplicated' thish examines element by element in a vector to find out whether the next element has already appeared before in the vector.
comadre_sub <- comadre_sub[which(duplicated(comadre_sub$SpeciesAccepted)==FALSE),] # comadre_sub now only contains unique rows based on the values in the column 'SpeciesAccepted', so each MPM only represents one species 
dim(comadre_sub)



```

```{r, echo = FALSE}
#Accessing the IUCN data
#https:/apiv3.iucnredlist.org'.

API_token <- "8d9c556bb4aa2efeacdc49775c0d0514b42139c96d5ed0f6b9ca5a495ffa49a4"
#Using the API token to extract information from IUCN 

IUCN.list <- iucn_summary(comadre_sub$SpeciesAccepted, distr_detail = FALSE, key = API_token)
#runs a summary of data extracted from the IUCN for my species names. 

```




```{r, echo = FALSE}

#The following code is data wrangling which ensures I only obtain information about IUCN redlist status for each of my unique reptile species (of which there are 25) and nothing else. I am then binding this information back onto the comadre data that I generated above. 
#This IUCN list contains a lot of information for each species. I am only obtaining information about their classification and species name. 

#the following code takes the IUCN.list, extracts status information from each element, combines them into a single tibble and then adds a new column SpeciesAccepted to this tibble with values from comadre_sub$SpeciesAccepted. 

IUCN_data <- lapply(IUCN.list, function(x){ #iterates over each element x in the IUCN list. 
  return(tibble(IUCNstatus = x$status))}) %>% #For each element it creates a data frame with a single column named IUCN status containing the status information extracted from the status field of the element x. 
  bind_rows() %>%  #Uses the dplyr package to pipe the list of tibbles obtained from the lapply() function into the bind_rows function. Binds all the tibbles together row wise, essentially combining them into a single tibble. 
  mutate(SpeciesAccepted = comadre_sub$SpeciesAccepted) #creates a new column called SpeciesAccepted and assigns the values of comadre_sub$SpeciesAccepted to it, adding a new column to the combined tibble 



#Now linking this back to original data using the left_join() function
comadre_iucn <- comadre_sub %>%
  left_join(x = ., y = IUCN_data, by = "SpeciesAccepted") %>% 
  mutate(IUCNstatus = case_when(
    IUCNstatus == "EN" ~ "Endangered",
    IUCNstatus == "VU" ~ "Vulnerable",
    IUCNstatus == "NT" ~ "Near Threatened",
    IUCNstatus == "LC" ~ "Least Concern",
    is.na(IUCNstatus) == TRUE ~ "Not Assessed"),
    IUCNstatus = factor(IUCNstatus, 
                        levels = c("Endangered","Vulnerable",
                                   "Near Threatened","Least Concern",
                                   "Not Assessed")))
#whenever it is vulnerable, writing it as Vu, etc.

#linking data from IUCN_data back to the original comadre_sub based on SpeciesAccepted column, then transforming the IUCNstatus column to a factor and assigning specific lvels based on the orignal status values. 
dim(comadre_iucn)

#We are going to flatten out this object into a simple data.frame
comadre_iucn <- as.data.frame(comadre_iucn) 

#Adding colours to the IUCN categories
comadre_iucn$iucn_colour <- NA
#Making a variable to accomodate colour 
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Endangered")] <- "Red" 
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Vulnerable")] <- "Orange"
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Near Threatened")] <- "Dark green"
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Least Concern")] <- "Green"
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Not Assessed")] <- "Blue"

head(comadre_iucn)
dim(comadre_iucn)

```




Exploring visually and statistically whether generation time and population growth rate predict conservation status:
```{r}
#Exploring the relationship between generation time and population growth rate 
ggplot(comadre_iucn, aes(x = IUCNstatus, y = gen_T, 
                         fill = IUCNstatus)) + 
  geom_boxplot(show.legend = F) +
  geom_jitter(width = 0.2, show.legend = F) +
  scale_fill_viridis_d(option = "B", begin = 0.3, end = 0.8) +
  labs(x = "IUCN redlist status", y = "Generation time (years)") +
  theme_classic(base_size = 14)
#Created a boxplot of generation time against IUCN status.  

ANOVA_gen_T <- aov(gen_T~IUCNstatus, data = comadre_iucn)
summary(ANOVA_gen_T)
#The p value is > 0.05 so the relationship is not significant 

#Now plotting population growth rate against IUCN status 
ggplot(comadre_iucn, aes(x = IUCNstatus, y = lambda, 
                         fill = IUCNstatus)) + 
  geom_boxplot(show.legend = F) +
  geom_jitter(width = 0.2, show.legend = F) +
  scale_fill_viridis_d(option = "B", begin = 0.3, end = 0.8) +
  labs(x = "IUCN redlist status", y = "Population growth rate") +
  theme_classic(base_size = 14)

ANOVA_lambda <- aov(lambda~IUCNstatus, data = comadre_iucn)
summary(ANOVA_lambda)
#P is also > 0.05 so the relationship is not significant 

```

The p value of my ANOVA of generation time and conservation status is 0.398. This is greater than 0.05 so generation time does not significantly predict conservation status. The P value for my ANOVA of population growth rate and conservation status is 0.249. This is greater than 0.05 so it is not significant.  Generation time and population growth cannot be used to predict conservation status. This is somewhat expected as the data concerns wild populations so many other factors may be more important in predicting conservation status. A correlation may be expected in captivity, since populations with a lambda value close to 1 are at demographic equilibrium and ought to be stable and not endangered. Populations with shorter generation times respond faster to environmental stress thus might be expected not to be endangered. 


QUESTION 4: 
```{r, echo = FALSE}

my_taxa <- comadre_iucn$SpeciesAccepted
#We are checking whether the species names are taxonomic ally accepted 


resolved_names <- rotl::tnrs_match_names(names = my_taxa)
#Using the command 'tnrs_match_names' to run my_taxa through the API of ROTL to check species names
resolved_names
#Inspecting the produced table called resolved_names which provides taxonomically and additional information such as unique ott_id which I will later use to obtain phylogenetic tree information from the open tree of life (OTL)
#OTT ID is the unique number given to any species across the tree of life. 


comadre_iucn$ott_id <- resolved_names$ott_id
#Within resolved _names, there is a variable called ott_id which we are interested, we are adding this variable to our data frame
dim(comadre_iucn)
comadre_iucn <- comadre_iucn[is.na(comadre_iucn$ott_id) == FALSE,]
#Getting rid of any NAs 
dim(comadre_iucn)

```

```{r}


#Removing the species Zonosaurus sp from comadre_iucn because it is incertae sedis so it has been pruned from the current tree of life as its precise position in the open tree of life is uncertain 

# Remove the 24th row
comadre_iucn <- comadre_iucn %>%
  slice(-25)

dim(comadre_iucn)

```


```{r}
my_taxa <- comadre_iucn$SpeciesAccepted
#Making a new dataset with the currently accepted names of the species 
resolved_names <- rotl::tnrs_match_names(names = my_taxa)
#using the function tnrs_match_names() function from the rotl package to query the taxonomic resolution service, TNRS using the taxonomic names stored in my_taxa and storing results in resolved_names
comadre_iucn$OTL_unique_name <- resolved_names$unique_name
#Passing on this information to the repository to make sure all these are currently accepted names 

#Adding the names of the species to the data.frame for later merging to the phylogenetic tree with this data.frame
#Data frame you use needs to have species names as row names 
row.names(comadre_iucn) <- resolved_names$unique_name

```

```{r}

#Obtain the phylogenetic tree for your species
my_tree <- rotl::tol_induced_subtree(resolved_names$ott_id)
#making a phylogenetic tree from my dataset resolved_names by communicating our OTT IDs to the OTL and returning only the phylogeny containing hits corresponding to my reptile species. 

#Delete the ott ids 
my_tree$tip.label <- gsub('_ott', '', my_tree$tip.label)
my_tree$tip.label <- gsub('[0-9]+', '', my_tree$tip.label)
#deleting numbers from tip labels 
my_tree$tip.label <- gsub('_', ' ', my_tree$tip.label)

my_tree$tip.label

#Plotting my new tree

plot(my_tree, cex = 0.8)



```

Plotting generation time and population growth rate onto a tree 

```{r, echo = FALSE}
#We will be using the R package phytools


setwd("/Users/cissi.user.2/Documents/Computer coding/Large datasets assignment")
tree <- read.tree("COMPADRE-COMADRE_Phylo_June_16_2019.tre")
#I am downloading the tree of life and changing my working directory to the appropriate locaiton, and then reading the tree into my R. The tree contains lots of information about plants and animals in comadre and compadre. 

plot(tree) #plotting this tree 


tree$tip.label <- gsub("_", " ", tree$tip.label) #cleaning the names in the tree so they can be compared with the names in our object, by removing underscores for plotting

pruned_tree <- drop.tip(tree, setdiff(tree$tip.label, comadre_iucn$OTL_unique_name)) #pruning the tree to cut out the branches not present in my dataset using the setdiff function which informs us which elements in the first vector are not present in the second vector. 

pruned_tree
plot(pruned_tree)


```

```{r, echo = FALSE}

# Extract tip labels from the tree object
tree_tip_labels <- tree$tip.label

# Extract tip labels from the comadre_iucn_pruned data frame
comadre_iucn_tip_labels <- comadre_iucn$OTL_unique_name

# Compare the two sets of tip labels
matching_labels <- intersect(tree_tip_labels, comadre_iucn_tip_labels)

# Displaying the matching tip labels
print(matching_labels)

# Checking if there are any tip labels in comadre_iucn that are not in the tree
missing_labels <- setdiff(comadre_iucn_tip_labels, tree_tip_labels)
print(missing_labels)

# Check if there are any tip labels in the tree that are not in comadre_iucn_pruned
extra_labels <- setdiff(tree_tip_labels, comadre_iucn_tip_labels)
print(extra_labels)
```


```{r, echo = FALSE}


comadre_iucn$OTL_unique_name[which(comadre_iucn$OTL_unique_name%in%pruned_tree$tip.label==F)]
#Locating all the items that are in one of the datasets and not the other one and outputting this. The function %in% says for every slot in the first vector, are you present in the second vector? Asking if all the species are present in the phylogeny. 

comadre_iucn <- comadre_iucn[-which(comadre_iucn$OTL_unique_name%in%pruned_tree$tip.label==F),]
#We are matching the tip labels of the pruned tree to the unique names of the IUCN list. We are modifying the subset so the order of species matches the order in the phylogeny so we can map the two against eachother. 
dim(comadre_iucn)

#Next, we need will reorder the comadre_iucn order so the species appear in the same order in which they appear in the tree
comadre_iucn <- comadre_iucn[match(pruned_tree$tip.label,comadre_iucn$OTL_unique_name),]
dim(comadre_iucn)

#Ensuring that the order is the same between the object and the tree
comadre_iucn$OTL_unique_name
pruned_tree$tip.label
#they are in the same order, so we can proceed to the next steps. 

#I will now plot the values of population growth rate at the tips of the phylogeny, and reconstruct the ancestral state of the originating lineage
log_lambdas <- log(setNames(comadre_iucn$lambda, rownames(comadre_iucn)))
#creating an object called log lambdas which has the species name and the value of log lambda, the log of population growth rate 

# create "contMap" object, which allows for the reconstruction of likely ancestral traits

#We will now visually plot the value of log lambda against the phylogeny of reptile species where values in red correspond to high values of population growth rate and values in yellow are relatively low. 

#Is there a pattern? Same population growth rate across one clade, or no? Should you expect that performance of a population should be the same for all primates or all wild cats or all corals? Should there be phylogenetic grouping?

mammal_contMap_lambda <- contMap(pruned_tree, log_lambdas,plot=FALSE,res=200)
mammal_contMap_lambda <- setMap(mammal_contMap_lambda, c("white","#FFFFB2","#FECC5C","#FD8D3C","#E31A1C"))
plot(mammal_contMap_lambda, fsize=c(0.7,0.8), leg.txt="log(population growth rate)")
par(mar=c(5.1,4.1,4.1,2.1)) ## reset margins to default

#Chelonia mydas and Caretta caretta show high population growth rate and they are in the same clade 

#Let's do the same thing for generation time
log_gen_T <- log(setNames(comadre_iucn$gen_T, rownames(comadre_iucn)))
mammal_contMap_gen_T <- contMap(pruned_tree, log_gen_T,plot=FALSE,res=200)
mammal_contMap_gent_T <- setMap(mammal_contMap_gen_T, c("white","light blue","blue","violet","purple"))
plot(mammal_contMap_gent_T, fsize=c(0.7,0.8), leg.txt="log(generation time) (years)")

#You do see grouping here, species that are more closely related have more similar generation times, eg Xenosaurus grandis, Xenosaurus platyceps, Scleroporous arenicolus and Scleroporus grammicus have more similar, shorter generation times, so there is evidence of phylogenetic inertia. Think about a mechanism whereby generation time is phylogenetically conserved! Age of reproduction difference between two groups of individuals it would create reproductive problems. Does this mechanism explain this pattern? yes, speciation would be caused if the age of reproduction of two groups diverged. explaisn why more closely related individulas have similar generatoin times.



```
Phylogenetic inertia is the limitations on future evolutionary pathways imposed by previous adaptations. There is evidence of phylogenetic inertia for generation time. Generation times change gradually across evolutionary time but change is constrained within clades. More closely related species within the same clade have more similar generation times resulting in clustering of traits in the tree. For example Xenosaurus platycepts are more closely related to each other and share a low log generation time. Generation time is constrained within clades since closely related species must have similar generation times in order to be able to reproduce. 

There is little evidence of phylogenetic inertia for population growth rate, as there is little clustering of different population growth rates along lineages in this tree. This is expected as population growth rate is controlled by environmental factors. 



QUESTION 5 

```{r, echo = FALSE}
#Making a new variable called population performance where if lambda is greater than 1 it is assigned Increase, and if lambda is less than 1 Population performance is assigned decline. 
# Creating an empty vector to store the values of the new variable Population performance 

new_variable <- vector()

# Iterating over each row in the data frame
for (i in 1:nrow(comadre_iucn)) {
  # Checking the value of lambda for each species
  if (comadre_iucn$lambda[i] > 1) {
    new_variable <- c(new_variable, 'Increase')
  } else if (comadre_iucn$lambda[i] < 1) {
    new_variable <- c(new_variable, 'Decline')
  }
}

#need to explain what this for loop is doing 

# Adding the new variable to the data frame
comadre_iucn$Population_performance <- new_variable

# Displaying the updated data frame
print(comadre_iucn)
dim(comadre_iucn)
head(comadre_iucn)
```

```{r, echo = FALSE}
#Creating a new variable called Population_performance_colour

# Creating an empty vector to store the values of the new variable
population_performance_colour <- vector()

# Iterating over each value in the Population_performance variable
for (i in 1:length(comadre_iucn$Population_performance)) {
  # Checking the value of Population_performance for each species
  if (comadre_iucn$Population_performance[i] == 'Increase') {
    population_performance_colour <- c(population_performance_colour, 'blue')
  } else if (comadre_iucn$Population_performance[i] == 'Decline') {
    population_performance_colour <- c(population_performance_colour, 'red')
  }
}

# Adding the new variable to the data frame
comadre_iucn$Population_performance_colour <- population_performance_colour

# Displaying the updated data frame
print(comadre_iucn)

#assigning a colour to population performance where blue is for Increase and red is for Decline 


```




```{r, echo = FALSE}
#Changing IUCN status to letters for better visualisation 
comadre_iucn <- comadre_iucn %>%
  mutate(IUCNstatus = case_when(
    IUCNstatus == "Endangered" ~ "EN",
    IUCNstatus == "Vulnerable" ~ "VU",
    IUCNstatus == "Near Threatened" ~ "NT",
    IUCNstatus == "Least Concern" ~ "LC",
    IUCNstatus == "Not Assessed" ~ "NA",
    is.na(IUCNstatus) ~ "NA",  # Change NA values to "NA"
    TRUE ~ IUCNstatus  # Keep unchanged if not matched
  ))

head(comadre_iucn)


```





```{r}
#creating a new tree
new_scaled_tree <- pruned_tree

#adjusting the branch lengths 
scaling_factor <- 10 
new_scaled_tree$edge.length <- new_scaled_tree$edge.length * scaling_factor

#saving as a png 
png("phylogeny_large.original.png", width = 1400, height = 1200)

#plotting the scaled phylogeny 
plot(new_scaled_tree, type = "phylogram", label.offset = 0.08, cex =)

#Adding tip labels for IUCN status and aligning them with the top right hand of the plot 

tiplabels(text = comadre_iucn$IUCNstatus,
          col = comadre_iucn$iucn_colour,
          cex = 1.1,
          frame = "none",
          bg = "transparent",
          font = 1.8,
          adj = -0.44) 

#Adding tip labels for population performance colour 

tiplabels(pch = 16, col = comadre_iucn$Population_performance_colour, cex = 1.3) 

#defining the legend labels and colours for population performance  

legend_colors <- c("red", "blue")
legend_labels <- expression(paste("Decrease (", lambda, " < 1)", sep = ""), 
                            paste("Increase (", lambda, " > 1)", sep = ""))



#defining lend and colours for IUCN status or th

iucn_status_legend <- c("green", "red", "orange", "darkgreen", "blue")
iucn_status_legend_labels <- c("LC = Least Concern", "EN = Endangered", "VU = Vulnerable", "NT = Near Threatened", "NA = Not Applicable")

#plotting these legends onto the plot 

legend("topright", legend = legend_labels, pch = 15, col = legend_colors,
       title = expression(paste("Population Performance (", lambda, ")", sep = "")), 
       cex = 1, inset = c(0, 0.135))

legend("topright", legend = iucn_status_legend_labels, pch = 15, col = iucn_status_legend,
       title = "IUCN status", cex = 1, text.col = "black", pt.bg = "transparent")



dev.off()




```





