---
title: "Large datasets assignment"
output: html_document
date: "2024-02-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r, echo = FALSE}
#Clear the R environment: if anything from a previous session is here it clears the objects that were made before. 
rm(list = ls())

```

```{r, echo = FALSE} 
#installing and loading the required packages

# Check if Rcompadre package is installed
if (!requireNamespace("Rcompadre", quietly = TRUE)) {
  # If not installed, install it
  install.packages("Rcompadre")
}

# Check if tidyverse package is installed
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  # If not installed, install it
  install.packages("tidyverse")
}

if (!requireNamespace("popbio", quietly = TRUE)) {
  # If not installed, install it
  install.packages("popbio")
}

if (!requireNamespace("Rage", quietly = TRUE)) {
  # If not installed, install it
  install.packages("Rage")
}

if (!requireNamespace("ggplot2", quietly = TRUE)) {
  # If not installed, install it
  install.packages("ggplot2")
}

if (!requireNamespace("taxsizw", quietly = TRUE)) {
  # If not installed, install it
  install.packages("taxsizw")
}

if (!requireNamespace("dplyr", quietly = TRUE)) {
  # If not installed, install it
  install.packages("dplyr")
}

if (!requireNamespace("phytools", quietly = TRUE)) {
  # If not installed, install it
  install.packages("phytools")
}






# Load the libraries
library(Rcompadre)
library(tidyverse)
library("popbio")
library("Rage")
library(ggplot2)
library(taxize)
library(dplyr)
library(phytools)






```



```{r, echo = FALSE}


#Fetch the most recent database version from www.compadre-db.org with:
comadre <- cdb_fetch("comadre") 
#This function takes comadre from the website www.comadre-db.org. This website has two databases, comadre for animals and compadre for plants. I am telling it to fetch comadre, 

#The command 'dim' tells me the dimension of the database comadre
dim(comadre)


```


```{r, echo = FALSE}
#Exploring the metadata in COMADRE. Metadata is 'extra' information surrounding my data.
comadre@data

#Examining all the possible classes in the dataset
unique_classes <- unique(comadre@data$Class)
# Print the unique classes
print(unique_classes)

```


```{r}
##In order to establish relationships between generation time and conservation status, we need to ensure that statistical inferences only concern these and no otehr confounding variables. We therefore subset the data to allow us to draw fair comparisons.
#subsetting my data to only include reptiles, and to only include wild individuals, not captive individuals. The species will also not be constrained geographically. 
comadre1 <- subset(comadre,
                   # Consider only reptiles
                   Class == "Reptilia" & 
                  #studied under "control" (i.e. no treatment) conditions
                   MatrixTreatment == "Unmanipulated" &
                   #only from "W"ild populations
                   MatrixCaptivity == "W")     

#taking a subset of the whole dataset to make a smaller dataset to make a subset of only the species we are interested in. The criterium being imposed are:
#just reptiles, with no geographical constraint.
#Matrix treatement unmanipulated, ie representing the dynamics of huge populations under natural conditions.
# The last criterium states that they are only from wild populations. 

#ensuring that there are at least 10 unique species in this subset:

#Examining all the possible classes in the dataset I could choose from 
unique_species_reptilia <- unique(comadre1$Species)
# Print the unique classes
length(unique_species_reptilia)
#There are 28 unique species of reptiles in this dataset. 

#calculating the dimensions of my new subsetted comadre1: 
dim(comadre1)


```



```{r echo = FALSE}

#We will use the function cdb_flag() to add columns to the database which flag potential issues with these MPMs. This could include missing values, or MPMs that don’t meet assumptions necessary to calculate population growth rates.


#we cannot calculate population growth rate from any data that has NAs attached or is not ergodic. 
#ergodic means that there is statistical equivalence between mean values measured over time and mean values measured across space 

#we are therefore further subsetting the data based of of these requirements 
comadre_flags <- cdb_flag(comadre1)
comadre_sub <- subset(comadre_flags,
                      check_NA_A == FALSE &
                      check_ergodic == TRUE)

#Check size of subset data again:
dim(comadre_sub)
head(comadre_sub) 

```






QUESTION 1:



```{r}
#I am going to obtain population growth rates using the function "lambda" from the R package "popbio
#Using the function lapply (which applies a function to every element in a list), I will calculate the population growth rate (lambda) for each matrix.


comadre_sub$lambda <- unlist(lapply(matA(comadre_sub), popbio::lambda))
#from my subset that I have made from comadre I will call the MPM matA (the rate of growth of the pouplation) and apply the lambda function to it which will extract the growth rate. 

#Examining the distribution of population growth rates:
hist(comadre_sub$lambda, xlab= "Population growth rate", main = "Frequency distribution of Population growth rates")
abline(v = 1, col = 'red', lty = 2, lwd = 2) #this histogram shows the frequency distribution of population growth rates
#This line of code adds a verticle line at x = 1. 

#Populations change over time so if you want to consider a population over time the value of lambda changes, for example this might come from an abnormally good year. if you assume as many resources and that density dependence isnt important (hasnt reached carrying capacity) lambda would be higher than one. So unless you calculate lambda through a lot of matrix following populations over a long time this is problematic. 





```
The frequency distribution  of population growth rate centers around the value of 1. Most of the populations are not changing in size and are at demographic equilibrium. This is expected. If the conditions under which the matrix was parameterized do not change the population will remain stable. Density dependence causes population growth rates to tend to 1 since increasing beyond this value causes populations to exhaust their finite resources so population size decreases. There are some cases of larger population growth rate shown by the right skew of the distribution.  These may be outliers and may be recovering from a perturbation. 

Generating a histogram for distributions of generation time: 

```{r}
#To calculate generation time, we will use the R package "Rage"

#Again using the function lapply, we will now use the matrices U and F to find information about generation time 
#to calculate the generation time
comadre_sub$gen_T <- mapply(Rage::gen_time, matU(comadre_sub), matF(comadre_sub))
#In order to calculate generation time we must split the overall MPM up into sub matrices. We  require the sub matrix U (survival and growth) and F which includes sexual reproduction.

#Examining the distribution of generation times where generation time refers to the number of years from birth to reproduction.


hist(comadre_sub$gen_T, xlab = "Generation time (years)", main = "Frequency distribution of generation times")
#there is a higher frequency of populations with shorter generation times 

```

There is a higher frequency of populations with shorter generation times, especially between 0- 10 years. This is expected as populations with shorter generation times respond faster to environmental stress and evolve faster, and are therefore a positively selected feature. The distribution is right skewed as some reptiles have very long lifespans. 


QUESTION 2: Exploring whether there is a correlation between population growth rate and generation time: 



```{r, echo = FALSE}
#The data about population growth rate is: 
comadre_sub$lambda
#The data about generation time is: 
comadre_sub$gen_T


#The following code checks if there are NAs in lambda values and removes them. This is a conditional if loop that gets rid of nas that in this case isn't fulfilled as there are not any NAs in this dataset.
if (length(which(is.na(comadre_sub$lambda)))>0) {
  comadre_sub <- comadre_sub[-which(is.na(comadre_sub$lambda)),]
}

if (length(which(is.na(comadre_sub$gen_T)))>0) {
  comadre_sub <- comadre_sub[-which(is.na(comadre_sub$gen_T)),]
}


if (length(which(is.infinite(comadre_sub$gen_T)))>0) {
  comadre_sub <- comadre_sub[-which(is.infinite(comadre_sub$gen_T)),]
}

```


```{r}


#Creating a scatter plot of generation time against population growth rate 
ggplot(comadre_sub, aes(x = gen_T, y = lambda)) +
  geom_point() +  # Add points for each data point
  labs(x = "Generation Time", y = "Population Growth Rate") +  # Label axes
  ggtitle("Scatter Plot of Generation Time vs Population Growth Rate")  


# Extracting the variables
population_growth_rate <- comadre_sub$lambda
generation_time <- comadre_sub$gen_T

# Running correlation test
correlation_test_result <- cor.test(generation_time, population_growth_rate)

# Print the correlation test result
print(correlation_test_result)


```
The p value for my pearson’s correlation test is 0.2615. This value is greater than 0.05 therefore there is no statistically significant correlation between population growth rate and generation time. This is not expected. We would expect a correlation as shorter generation times should cause populations to increase faster since organisms with shorter generation times produce more offspring per unit of time. 
More correlation might have been expected if there was more variation seen in the population growth rates. However since population growth rate tends around 1, no correlation with generation time can be observed. 

QUESTION 3: 


```{r, message=FALSE, error=FALSE, warning=FALSE, echo = FALSE}
#Note that the object 'comadre_sub' contains multiple MPMs for each species. Sometimes these MPMs correspond to different years within the same population, or they may refer to different populations, or come from different publications or research groups. We will only sample one MPM per species:

#In the following line of code I will select the first entry of the whole of comadre_sub where ther is a new species using the command 'duplicated' thish examines element by element in a vector to find out whether the next element has already appeared before in the vector.
comadre_sub <- comadre_sub[which(duplicated(comadre_sub$SpeciesAccepted)==FALSE),] # comadre_sub now only contains unique rows based on the values in the column 'SpeciesAccepted', so each MPM only represents one species 
dim(comadre_sub)



```

```{r, echo = FALSE}
#Accessing the IUCN data
#https:/apiv3.iucnredlist.org'.

API_token <- "8d9c556bb4aa2efeacdc49775c0d0514b42139c96d5ed0f6b9ca5a495ffa49a4"
#Using the API token to extract information from IUCN 

IUCN.list <- iucn_summary(comadre_sub$SpeciesAccepted, distr_detail = FALSE, key = API_token)
#runs a summary of data extracted from the IUCN for my species names. 

```




```{r, echo = FALSE}

#The following code is data wrangling which ensures I only obtain information about IUCN redlist status for each of my unique reptile species (of which there are 25) and nothing else. I am then binding this information back onto the comadre data that I generated above. 
#This IUCN list contains a lot of information for each species. I am only obtaining information about their classification and species name. 

#the following code takes the IUCN.list, extracts status information from each element, combines them into a single tibble and then adds a new column SpeciesAccepted to this tibble with values from comadre_sub$SpeciesAccepted. 

IUCN_data <- lapply(IUCN.list, function(x){ #iterates over each element x in the IUCN list. 
  return(tibble(IUCNstatus = x$status))}) %>% #For each element it creates a data frame with a single column named IUCN status containing the status information extracted from the status field of the element x. 
  bind_rows() %>%  #Uses the dplyr package to pipe the list of tibbles obtained from the lapply() function into the bind_rows function. Binds all the tibbles together row wise, essentially combining them into a single tibble. 
  mutate(SpeciesAccepted = comadre_sub$SpeciesAccepted) #creates a new column called SpeciesAccepted and assigns the values of comadre_sub$SpeciesAccepted to it, adding a new column to the combined tibble 



#Now linking this back to original data using the left_join() function
comadre_iucn <- comadre_sub %>%
  left_join(x = ., y = IUCN_data, by = "SpeciesAccepted") %>% 
  mutate(IUCNstatus = case_when(
    IUCNstatus == "EN" ~ "Endangered",
    IUCNstatus == "VU" ~ "Vulnerable",
    IUCNstatus == "NT" ~ "Near Threatened",
    IUCNstatus == "LC" ~ "Least Concern",
    is.na(IUCNstatus) == TRUE ~ "Not Assessed"),
    IUCNstatus = factor(IUCNstatus, 
                        levels = c("Endangered","Vulnerable",
                                   "Near Threatened","Least Concern",
                                   "Not Assessed")))
#whenever it is vulnerable, writing it as Vu, etc.

#linking data from IUCN_data back to the original comadre_sub based on SpeciesAccepted column, then transforming the IUCNstatus column to a factor and assigning specific lvels based on the orignal status values. 
dim(comadre_iucn)

#We are going to flatten out this object into a simple data.frame
comadre_iucn <- as.data.frame(comadre_iucn) 

#Adding colours to the IUCN categories
comadre_iucn$iucn_colour <- NA
#Making a variable to accomodate colour 
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Endangered")] <- "Red" 
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Vulnerable")] <- "Orange"
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Near Threatened")] <- "Dark green"
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Least Concern")] <- "Green"
comadre_iucn$iucn_colour[which(comadre_iucn$IUCNstatus == "Not Assessed")] <- "Blue"

head(comadre_iucn)
dim(comadre_iucn)

```




Exploring visually and statistically whether generation time and population growth rate predict conservation status:
```{r}
#Exploring the relationship between generation time and population growth rate 
ggplot(comadre_iucn, aes(x = IUCNstatus, y = gen_T, 
                         fill = IUCNstatus)) + 
  geom_boxplot(show.legend = F) +
  geom_jitter(width = 0.2, show.legend = F) +
  scale_fill_viridis_d(option = "B", begin = 0.3, end = 0.8) +
  labs(x = "IUCN redlist status", y = "Generation time (years)") +
  theme_classic(base_size = 14)
#Created a boxplot of generation time against IUCN status.  

ANOVA_gen_T <- aov(gen_T~IUCNstatus, data = comadre_iucn)
summary(ANOVA_gen_T)
#The p value is > 0.05 so the relationship is not significant 

#Now plotting population growth rate against IUCN status 
ggplot(comadre_iucn, aes(x = IUCNstatus, y = lambda, 
                         fill = IUCNstatus)) + 
  geom_boxplot(show.legend = F) +
  geom_jitter(width = 0.2, show.legend = F) +
  scale_fill_viridis_d(option = "B", begin = 0.3, end = 0.8) +
  labs(x = "IUCN redlist status", y = "Population growth rate") +
  theme_classic(base_size = 14)

ANOVA_lambda <- aov(lambda~IUCNstatus, data = comadre_iucn)
summary(ANOVA_lambda)
#P is also > 0.05 so the relationship is not significant 

```

The p value of my ANOVA of generation time and conservation status is 0.398. This is greater than 0.05 so generation time does not significantly predict conservation status. The P value for my ANOVA of population growth rate and conservation status is 0.249. This is greater than 0.05 so it is not significant.  Generation time and population growth cannot be used to predict conservation status. This is somewhat expected as the data concerns wild populations so many other factors may be more important in predicting conservation status. A correlation may be expected in captivity, since populations with a lambda value close to 1 are at demographic equilibrium and ought to be stable and not endangered. Populations with shorter generation times respond faster to environmental stress thus might be expected not to be endangered. 


QUESTION 4: 
```{r, echo = FALSE}

my_taxa <- comadre_iucn$SpeciesAccepted
#We are checking whether the species names are taxonomic ally accepted 


resolved_names <- rotl::tnrs_match_names(names = my_taxa)
#Using the command 'tnrs_match_names' to run my_taxa through the API of ROTL to check species names
resolved_names
#Inspecting the produced table called resolved_names which provides taxonomically and additional information such as unique ott_id which I will later use to obtain phylogenetic tree information from the open tree of life (OTL)
#OTT ID is the unique number given to any species across the tree of life. 


comadre_iucn$ott_id <- resolved_names$ott_id
#Within resolved _names, there is a variable called ott_id which we are interested, we are adding this variable to our data frame
dim(comadre_iucn)
comadre_iucn <- comadre_iucn[is.na(comadre_iucn$ott_id) == FALSE,]
#Getting rid of any NAs 
dim(comadre_iucn)

```

```{r}


#Removing the species Zonosaurus sp from comadre_iucn because it is incertae sedis so it has been pruned from the current tree of life as its precise position in the open tree of life is uncertain 

# Remove the 24th row
comadre_iucn <- comadre_iucn %>%
  slice(-25)

dim(comadre_iucn)

```


```{r}
my_taxa <- comadre_iucn$SpeciesAccepted
#Making a new dataset with the currently accepted names of the species 
resolved_names <- rotl::tnrs_match_names(names = my_taxa)
#using the function tnrs_match_names() function from the rotl package to query the taxonomic resolution service, TNRS using the taxonomic names stored in my_taxa and storing results in resolved_names
comadre_iucn$OTL_unique_name <- resolved_names$unique_name
#Passing on this information to the repository to make sure all these are currently accepted names 

#Adding the names of the species to the data.frame for later merging to the phylogenetic tree with this data.frame
#Data frame you use needs to have species names as row names 
row.names(comadre_iucn) <- resolved_names$unique_name

```

```{r}

#Obtain the phylogenetic tree for your species
my_tree <- rotl::tol_induced_subtree(resolved_names$ott_id)
#making a phylogenetic tree from my dataset resolved_names by communicating our OTT IDs to the OTL and returning only the phylogeny containing hits corresponding to my reptile species. 

#Delete the ott ids 
my_tree$tip.label <- gsub('_ott', '', my_tree$tip.label)
my_tree$tip.label <- gsub('[0-9]+', '', my_tree$tip.label)
#deleting numbers from tip labels 
my_tree$tip.label <- gsub('_', ' ', my_tree$tip.label)

my_tree$tip.label

#Plotting my new tree

plot(my_tree, cex = 0.8)



```

Plotting generation time and population growth rate onto a tree 

```{r, echo = FALSE}
#We will be using the R package phytools


setwd("/Users/cissi.user.2/Documents/Computer coding/Large datasets assignment")
tree <- read.tree("COMPADRE-COMADRE_Phylo_June_16_2019.tre")
#I am downloading the tree of life and changing my working directory to the appropriate locaiton, and then reading the tree into my R. The tree contains lots of information about plants and animals in comadre and compadre. 

plot(tree) #plotting this tree 


tree$tip.label <- gsub("_", " ", tree$tip.label) #cleaning the names in the tree so they can be compared with the names in our object, by removing underscores for plotting

pruned_tree <- drop.tip(tree, setdiff(tree$tip.label, comadre_iucn$OTL_unique_name)) #pruning the tree to cut out the branches not present in my dataset using the setdiff function which informs us which elements in the first vector are not present in the second vector. 

pruned_tree
plot(pruned_tree)


```

```{r, echo = FALSE}

# Extract tip labels from the tree object
tree_tip_labels <- tree$tip.label

# Extract tip labels from the comadre_iucn_pruned data frame
comadre_iucn_tip_labels <- comadre_iucn$OTL_unique_name

# Compare the two sets of tip labels
matching_labels <- intersect(tree_tip_labels, comadre_iucn_tip_labels)

# Displaying the matching tip labels
print(matching_labels)

# Checking if there are any tip labels in comadre_iucn that are not in the tree
missing_labels <- setdiff(comadre_iucn_tip_labels, tree_tip_labels)
print(missing_labels)

# Check if there are any tip labels in the tree that are not in comadre_iucn_pruned
extra_labels <- setdiff(tree_tip_labels, comadre_iucn_tip_labels)
print(extra_labels)
```


```{r, echo = FALSE}


comadre_iucn$OTL_unique_name[which(comadre_iucn$OTL_unique_name%in%pruned_tree$tip.label==F)]
#Locating all the items that are in one of the datasets and not the other one and outputting this. The function %in% says for every slot in the first vector, are you present in the second vector? Asking if all the species are present in the phylogeny. 

comadre_iucn <- comadre_iucn[-which(comadre_iucn$OTL_unique_name%in%pruned_tree$tip.label==F),]
#We are matching the tip labels of the pruned tree to the unique names of the IUCN list. We are modifying the subset so the order of species matches the order in the phylogeny so we can map the two against eachother. 
dim(comadre_iucn)

#Next, we need will reorder the comadre_iucn order so the species appear in the same order in which they appear in the tree
comadre_iucn <- comadre_iucn[match(pruned_tree$tip.label,comadre_iucn$OTL_unique_name),]
dim(comadre_iucn)

#Ensuring that the order is the same between the object and the tree
comadre_iucn$OTL_unique_name
pruned_tree$tip.label
#they are in the same order, so we can proceed to the next steps. 

#I will now plot the values of population growth rate at the tips of the phylogeny, and reconstruct the ancestral state of the originating lineage
log_lambdas <- log(setNames(comadre_iucn$lambda, rownames(comadre_iucn)))
#creating an object called log lambdas which has the species name and the value of log lambda, the log of population growth rate 

# create "contMap" object, which allows for the reconstruction of likely ancestral traits

#We will now visually plot the value of log lambda against the phylogeny of reptile species where values in red correspond to high values of population growth rate and values in yellow are relatively low. 

#Is there a pattern? Same population growth rate across one clade, or no? Should you expect that performance of a population should be the same for all primates or all wild cats or all corals? Should there be phylogenetic grouping?

mammal_contMap_lambda <- contMap(pruned_tree, log_lambdas,plot=FALSE,res=200)
mammal_contMap_lambda <- setMap(mammal_contMap_lambda, c("white","#FFFFB2","#FECC5C","#FD8D3C","#E31A1C"))
plot(mammal_contMap_lambda, fsize=c(0.7,0.8), leg.txt="log(population growth rate)")
par(mar=c(5.1,4.1,4.1,2.1)) ## reset margins to default

#Chelonia mydas and Caretta caretta show high population growth rate and they are in the same clade 

#Let's do the same thing for generation time
log_gen_T <- log(setNames(comadre_iucn$gen_T, rownames(comadre_iucn)))
mammal_contMap_gen_T <- contMap(pruned_tree, log_gen_T,plot=FALSE,res=200)
mammal_contMap_gent_T <- setMap(mammal_contMap_gen_T, c("white","light blue","blue","violet","purple"))
plot(mammal_contMap_gent_T, fsize=c(0.7,0.8), leg.txt="log(generation time) (years)")

#You do see grouping here, species that are more closely related have more similar generation times, eg Xenosaurus grandis, Xenosaurus platyceps, Scleroporous arenicolus and Scleroporus grammicus have more similar, shorter generation times, so there is evidence of phylogenetic inertia. Think about a mechanism whereby generation time is phylogenetically conserved! Age of reproduction difference between two groups of individuals it would create reproductive problems. Does this mechanism explain this pattern? yes, speciation would be caused if the age of reproduction of two groups diverged. explaisn why more closely related individulas have similar generatoin times.



```
Phylogenetic inertia is the limitations on future evolutionary pathways imposed by previous adaptations. There is evidence of phylogenetic inertia for generation time. Generation times change gradually across evolutionary time but change is constrained within clades. More closely related species within the same clade have more similar generation times resulting in clustering of traits in the tree. For example Xenosaurus platycepts are more closely related to each other and share a low log generation time. Generation time is constrained within clades since closely related species must have similar generation times in order to be able to reproduce. 

There is little evidence of phylogenetic inertia for population growth rate, as there is little clustering of different population growth rates along lineages in this tree. This is expected as population growth rate is controlled by environmental factors. 



QUESTION 5 

```{r, echo = FALSE}
#Making a new variable called population performance where if lambda is greater than 1 it is assigned Increase, and if lambda is less than 1 Population performance is assigned decline. 
# Creating an empty vector to store the values of the new variable Population performance 

new_variable <- vector()

# Iterating over each row in the data frame
for (i in 1:nrow(comadre_iucn)) {
  # Checking the value of lambda for each species
  if (comadre_iucn$lambda[i] > 1) {
    new_variable <- c(new_variable, 'Increase')
  } else if (comadre_iucn$lambda[i] < 1) {
    new_variable <- c(new_variable, 'Decline')
  }
}

#need to explain what this for loop is doing 

# Adding the new variable to the data frame
comadre_iucn$Population_performance <- new_variable

# Displaying the updated data frame
print(comadre_iucn)
dim(comadre_iucn)
head(comadre_iucn)
```

```{r, echo = FALSE}
#Creating a new variable called Population_performance_colour

# Creating an empty vector to store the values of the new variable
population_performance_colour <- vector()

# Iterating over each value in the Population_performance variable
for (i in 1:length(comadre_iucn$Population_performance)) {
  # Checking the value of Population_performance for each species
  if (comadre_iucn$Population_performance[i] == 'Increase') {
    population_performance_colour <- c(population_performance_colour, 'blue')
  } else if (comadre_iucn$Population_performance[i] == 'Decline') {
    population_performance_colour <- c(population_performance_colour, 'red')
  }
}

# Adding the new variable to the data frame
comadre_iucn$Population_performance_colour <- population_performance_colour

# Displaying the updated data frame
print(comadre_iucn)

#assigning a colour to population performance where blue is for Increase and red is for Decline 


```
Explore in this handy website (http://blog.phytools.org) a way to plot that new trait on your phylogenetic tree. Then add another column to the phylogeny in such a way that you show the conservation status of those species (collected in previous steps from the IUCN). See picture below for reference/inspiration

Plotting pop_growth_rate onto my phylogenetic tree 



Applying the ACE (Ancestral Character Estimation) function to estimate the ancestral states of the discrete variable: (being above or below the median diversification rate) defined by my split column. This makes diversification rate a binary character: 

```{r}
recon <- ace(comadre_iucn_pruned$Population_performance, pruned_tree, type = "discrete")
#Viewing the likelihood of the ancestral states for all the nodes in the tree
recon
#You can see the likelihood of ancestral states for all nodes by extracting this part of the ace() output
recon$lik.anc

```
Plotting how diversification rates change over the course of the tree

```{r}
plot(pruned_tree, type = "phylogram", show.tip.label = FALSE)
cols <- c(Increase = "blue", Decline = "yellow") # Define colors for categories
tiplabels(pch = 22, cols[comadre_iucn_pruned$Population_performance], cex = 2)
nodelabels(thermo = recon$lik.anc, piecol = cols, cex = 0.75)
axisPhylo()

```
Modifying this code: 

```{r}
library(ape)

# Assuming pruned_tree is your phylogenetic tree object
# Assuming recon is your reconstruction object
# Assuming comadre_iucn_pruned$Population_performance contains categorical values ('Increase' or 'Decline')

# Plotting the phylogram
plot(pruned_tree, type = "phylogram", show.tip.label = FALSE)

# Define colors for categories
cols <- c(Increase = "blue", Decline = "yellow")

# Plot tip labels
tiplabels(pch = 22, col = cols[comadre_iucn_pruned$Population_performance], cex = 2, adj = 0)

# Plot node labels
nodelabels(thermo = recon$lik.anc, piecol = cols, cex = 0.75)

# Add axis
axisPhylo()


```

```{r}
# Assuming pruned_tree is your phylogenetic tree object
# Assuming recon is your reconstruction object
# Assuming comadre_iucn_pruned$Population_performance contains categorical values ('Increase' or 'Decline')

# Plotting the phylogenetic tree with tip labels
plot(pruned_tree, show.tip.label = TRUE)

# Define colors for categories
cols <- c(Increase = "blue", Decline = "yellow")

# Plot tip labels with colors
tiplabels(pch = 22, col = cols[comadre_iucn_pruned$Population_performance], cex = 2, adj = 0)

# Plot node labels
nodelabels(thermo = recon$lik.anc, piecol = cols, cex = 0.75)

# Add axis
axisPhylo()



```
Getting rid of the nodes key?

```{r}

# Assuming you have already loaded the ggphylo package
install.packages("ggphylo")
library(ggphylo)

# Your existing code
plot(pruned_tree, type = "phylogram", label.offset = 0.5)
cols <- c("blue", "yellow")
tiplabels(pch = 22, bg = cols[comadre_iucn$PopulationPerformance], cex = 2)

# Remove internal node labels
tree_without_labels <- tree.remove.node.labels(pruned_tree)

# Plot the modified tree
plot(tree_without_labels, type = "phylogram", label.offset = 0.5)
axisPhylo()
```




```{r, echo = FALSE}
#Changing IUCN status to letters for better visualisation 
comadre_iucn <- comadre_iucn %>%
  mutate(IUCNstatus = case_when(
    IUCNstatus == "Endangered" ~ "EN",
    IUCNstatus == "Vulnerable" ~ "VU",
    IUCNstatus == "Near Threatened" ~ "NT",
    IUCNstatus == "Least Concern" ~ "LC",
    IUCNstatus == "Not Assessed" ~ "NA",
    is.na(IUCNstatus) ~ "NA",  # Change NA values to "NA"
    TRUE ~ IUCNstatus  # Keep unchanged if not matched
  ))

head(comadre_iucn)


```


Plotting IUCN status onto my tree 

```{r}
recon2 <- ace(comadre_iucn_pruned$IUCNstatus, pruned_tree, type = "discrete")
#Viewing the likelihood of the ancestral states for all the nodes in the tree
recon2
#You can see the likelihood of ancestral states for all nodes by extracting this part of the ace() output
recon2$lik.anc


```
```{r}
# Assuming pruned_tree is your phylogenetic tree object
# Assuming recon is your reconstruction object
# Assuming comadre_iucn_pruned$Population_performance contains categorical values ('Increase' or 'Decline')
# Assuming comadre_iucn_pruned$IUCNstatus contains categorical values ('EN', 'VU', 'NT', 'LC', 'NA')

# Plotting the phylogenetic tree with tip labels
plot(pruned_tree, show.tip.label = TRUE)

# Define colors for categories
cols <- c(Increase = "blue", Decline = "yellow")
cols_iucn <- c("EN" = "red", "VU" = "orange", "NT" = "green", "LC" = "blue", "NA" = "gray")  # Define colors for IUCN status

# Plot tip labels with colors for Population_performance
tiplabels(pch = 22, col = cols[comadre_iucn_pruned$Population_performance], cex = 2, adj = 0)

# Plot tip labels with colors for IUCNstatus
tiplabels(pch = 22, col = cols_iucn[comadre_iucn_pruned$IUCNstatus], cex = 2, adj = 1)

# Plot node labels for Population_performance
nodelabels(thermo = recon$lik.anc, piecol = cols, cex = 0.75)

# Add additional labels for IUCNstatus
text(x = par("usr")[1] + 0.1, y = par("usr")[3] + 0.1, labels = comadre_iucn_pruned$IUCNstatus, col = cols_iucn[comadre_iucn_pruned$IUCNstatus], cex = 0.5, adj = 0)

# Add axis
axisPhylo()


```


```{r}
#using a new function to assign labels to my phylogenetic tree 
plotTree.lollipop<-function(tree,x,
  args.plotTree=list(),args.lollipop=list(),...){
  if(!inherits(x,c("matrix","data.frame"))) x<-as.matrix(x)
  h<-max(nodeHeights(tree))
  if(hasArg(panel_height)) panel_height<-list(...)$panel_height
  else panel_height<-1.0
  panel_height<-panel_height*h
  args.plotTree$tree<-tree
  args.plotTree$direction<-"upwards"
  if(is.null(args.plotTree$mar)) 
    args.plotTree$mar<-c(0.1,5.1,0.1,0.1)
  if(is.null(args.plotTree$ylim)) 
    args.plotTree$ylim<-c(0,h+ncol(x)*panel_height)
  if(is.null(args.plotTree$ftype)) 
    args.plotTree$ftype<-"off"
  if(is.null(args.plotTree$lwd)) args.plotTree$lwd<-1
  do.call(plotTree,args.plotTree)
  pp<-get("last_plot.phylo",envir=.PlotPhyloEnv)
  if(pp$font){
    dx<-abs(diff(pp$x.lim))
    pdin<-par()$din[2]
    sh<-(pp$cex*strwidth(paste(" ",tree$tip.label,sep=""))+
      0.3*pp$cex*strwidth("W"))*(par()$din[1]/par()$din[2])*
      (diff(par()$usr[3:4])/diff(par()$usr[1:2]))
    new_h<-h+max(sh)
    panel_height<-(h-new_h+ncol(x)*panel_height)/ncol(x)
    h<-new_h
  }
  if(hasArg(ylab)) ylab<-list(...)$ylab
  else ylab<-if(!is.null(colnames(x))) 
    colnames(x) else rep("",ncol(x))
  for(i in ncol(x):1){
    d<-max(c(diff(range(x[,i])),max(x[,i])))
    y<-setNames(x[,i]/d*0.8*panel_height,rownames(x))
    lower<-h+(i-1)*panel_height+panel_height*0.05
    upper<-h+(i-1)*panel_height+panel_height*0.95
    polygon(c(0,max(pp$xx)+1,max(pp$xx)+1,0),
      c(lower,lower,upper,upper),
      border=FALSE,col="#F2F2F2")
    hh<-lower-min(c(0,min(y)))+0.05*panel_height
    lines(range(pp$xx),rep(hh,2),col="black",lty="dotted")
    segments(x0=pp$xx[1:Ntip(tree)],y0=rep(hh,Ntip(tree)),
      x1=pp$xx[1:Ntip(tree)],y1=y[tree$tip.label]+hh)
    labs<-pretty(c(min(c(0,min(x[,i]))),x[,i]),n=4)
    labs[!(labs>max(x[,i]))]->labs
    labs[!(labs<min(c(0,min(x[,i]))))]->labs
    axis(2,at=hh+max(y)/max(x[,i])*labs,
      labels=labs,las=1,cex.axis=0.6)
    args.lollipop$bg<-setNames(
      viridisLite::viridis(n=100)[ceiling(99*((y-
          min(y))/diff(range(y))))+1],
      names(y))
    args.lollipop$bg<-args.lollipop$bg[tree$tip.label]
    if(is.null(args.lollipop$pch)) args.lollipop$pch<-21
    if(is.null(args.lollipop$cex)) args.lollipop$cex<-1.2
    args.lollipop$x<-pp$xx[1:Ntip(tree)]
    args.lollipop$y<-y[tree$tip.label]+hh
    do.call(points,args.lollipop)
    mtext(ylab[i],2,line=3,at=mean(hh+max(y)/
      max(x[,i])*labs),cex=0.8)
  }
}


```


```{r}


```


```{r}
library(phytools)

new_pruned_tree<-as.phylo(pruned_tree)
new_pruned_tree<-cbind(phyl.resid(new_pruned_tree,
  x=as.matrix(pruned_tree[,"Population_performance",drop=FALSE]),
  Y=as.matrix(pruned_tree[,c(6,4,2)]))$resid,
  exp(pruned_tree[,"Population_performance",drop=FALSE]))


```

```{r}

plotTree.lollipop(pruned_tree,log(pruned_tree),
  ylab=c("IUCN status","Population growth rate"),
  args.plotTree=list(fsize=0.7,ftype="i"),
  args.lollipop=list(cex=1.5),
  panel_height=2.5)


```

```{r}
# Assuming pruned_tree is your phylogenetic tree object
# Assuming comadre_iucn_pruned is your dataframe containing Population_performance and IUCNstatus columns

# Load the ape package if not already loaded
library(ape)

# Plot the phylogenetic tree with tip labels
plot(pruned_tree, show.tip.label = TRUE)

# Define colors for Increase and Decrease
cols <- c(Increase = "blue", Decrease = "red")

# Define colors for IUCN status
cols_iucn <- c("EN" = "red", "VU" = "orange", "NT" = "green", "LC" = "blue", "NA" = "gray")

# Add tip labels for IUCN status
tiplabels(pch = 22, col = cols_iucn[comadre_iucn_pruned$iucn_colour], cex = 1.5, adj = 0)

# Create custom labels based on Population_performance
lambda_values <- ifelse(comadre_iucn_pruned$Population_performance > 1, "Increase", "Decrease")

# Create node labels based on custom labels
node_labels <- ifelse(lambda_values == "Increase", ">1", "<1")

# Add node labels
nodelabels(node_labels, cex = 1.5)

# Add legend for Population_performance
legend("bottomleft", legend = c("Increase", "Decrease"), pch = 22, col = c("blue", "red"), title = "Population Performance", cex = 0.8)

# Add legend for IUCN status
legend("bottomright", legend = names(cols_iucn), pch = 22, col = cols_iucn, title = "IUCN Status", cex = 0.8)

# Add axis
axisPhylo()

```

```{r}
# Load the ape package if not already loaded
library(ape)

# Match the row names of the tree with the species names in the dataset
tip_labels <- match(comadre_iucn_pruned$Species, pruned_tree$tip.label)

# Assign tip labels to the tree
pruned_tree$tip.label <- comadre_iucn_pruned$Species[tip_labels]

# Plot the phylogenetic tree with tip labels
plot(pruned_tree, show.tip.label = TRUE)

# Define colors for Population_performance and IUCNstatus
cols_population <- c(Increase = "blue", Decline = "red")
cols_iucn <- c("EN" = "red", "VU" = "orange", "NT" = "green", "LC" = "blue", "NA" = "gray")

# Add tip labels for Population_performance
tiplabels(pch = 22, col = cols_population[comadre_iucn_pruned$Population_performance[tip_labels]], cex = 1.5, adj = 0)

# Add tip labels for IUCNstatus
tiplabels(pch = 22, col = cols_iucn[comadre_iucn_pruned$IUCNstatus[tip_labels]], cex = 1.5, adj = 1)

# Add axis
axisPhylo()




```



















```{r}
# Plot the tree
plot(pruned_tree, show.tip.label = TRUE, cex = 0.4)

# Plot tip labels with species names
tiplabels(pch = 22, text = comadre_iucn$IUCNstatus, bg = "white", cex = 0.5, adj = c(-7, 0.5))

# Get the maximum y-axis value of the plot
max_y <- max(par()$usr[3], par()$usr[4])

# Add legend for Population performance above the plot
legend("top", legend = unique(comadre_iucn$Population_performance), 
       pch = 22, 
       col = ifelse(unique(comadre_iucn$Population_performance) == "Decline", "red", "blue"), 
       pt.bg = "white", title = "Population performance", y = max_y + 0.1)

# Add Population_performance_colour information
tiplabels(pch = 22, text = "", col = comadre_iucn$Population_performance_colour, 
          bg = comadre_iucn$Population_performance_colour, cex = 1.2, add = TRUE)


```

Changing the parameters 
```{r}
# Plot the tree
plot(pruned_tree, show.tip.label = TRUE, cex = 0.4, adj = c(0.5, 0.5))

# Plot tip labels with species names
tiplabels(pch = 22, text = comadre_iucn$IUCNstatus, bg = "white", cex = 0.5, adj = c(-8, 0.5))

# Get the maximum y-axis value of the plot
max_y <- max(par()$usr[3], par()$usr[4])

# Add legend for Population performance above the plot
legend("top", legend = unique(comadre_iucn$Population_performance), 
       pch = 22, 
       col = ifelse(unique(comadre_iucn$Population_performance) == "Decline", "red", "blue"), 
       pt.bg = "white", title = "Population performance", y = max_y + 1)

# Add Population_performance_colour information
tiplabels(pch = 22, text = "", col = comadre_iucn$Population_performance_colour, 
          bg = comadre_iucn$Population_performance_colour, cex = 0.8, add = TRUE)

```
```{r}

# Plot the tree
plot(pruned_tree, show.tip.label = TRUE, cex = 0.4, adj = c(0.5, 0.5))

# Plot tip labels with species names
tiplabels(pch = 22, text = comadre_iucn$IUCNstatus, bg = "white", cex = 0.5, adj = c(-8, 0.5))

# Get the maximum y-axis value of the plot
max_y <- max(par()$usr[2], par()$usr[2])
max_y <- max_y - 2

# Add legend for Population performance above the plot
legend(x = "topright", y = max_y, # Adjust y value as needed
       legend = unique(comadre_iucn$Population_performance), 
       pch = 22, 
       col = ifelse(unique(comadre_iucn$Population_performance) == "Decline", "red", "blue"), 
       pt.bg = "white", title = "Population performance")

# Add Population_performance_colour information
tiplabels(pch = 22, text = "", col = comadre_iucn$Population_performance_colour, 
          bg = comadre_iucn$Population_performance_colour, cex = 0.8, add = TRUE)


```
```{r}
#this one has the correct tip labels for population performance 
new_scaled_tree <- pruned_tree

#adjusting the branch lengths 
scaling_factor <- 10 
new_scaled_tree$edge.length <- new_scaled_tree$edge.length * scaling_factor

png("phylogeny_large.original.png", width = 1400, height = 1200)

#plot the scaled phylogeny 
plot(new_scaled_tree, type = "phylogram", label.offset = 0.08, cex =)

#Adding tip labels for IUCN status and aligning them with the right edge of the plot 

tiplabels(text = comadre_iucn$IUCNstatus,
          col = comadre_iucn$iucn_colour,
          cex = 1.1,
          frame = "none",
          bg = "transparent",
          font = 1.8,
          adj = -0.44) 

#Add tip labels for population performance colour 

tiplabels(pch = 16, col = comadre_iucn$Population_performance_colour, cex = 1.3) 

#defining the legend labels and colours 

legend_colors <- c("red", "blue")
legend_labels <- c("Decrease", "Increase")

#defining the other legend labels and colours 

iucn_status_legend <- c("black", "darkred", "mediumorchid", "darkorange", "darkgreen")
iucn_status_legend_labels <- c("LC = Least Concern", "EN = Endangered", "VU = Vulnerable", "NT = Near Threatened", "NA = Not Applicable")

#plotting these legends onto the plot 

legend("topright", legend = legend_labels, pch = 15, col = legend_colors,
       title = "Population Performance", cex = 1, inset = c(0, 0.135))

legend("topright", legend = iucn_status_legend_labels, pch = 15, col = iucn_status_legend,
       title = "IUCN status", cex = 1, text.col = iucn_status_legend, pt.bg = "transparent")





dev.off()

```


```{r}
new_scaled_tree <- pruned_tree

#adjusting the branch lengths 
scaling_factor <- 10 
new_scaled_tree$edge.length <- new_scaled_tree$edge.length * scaling_factor

png("phylogeny_large.png", width = 1400, height = 1200)

#plot the scaled phylogeny 
plot(new_scaled_tree, type = "phylogram", label.offset = 0.08, cex =)

#Adding tip labels for IUCN status and aligning them with the right edge of the plot 

tiplabels(text = comadre_iucn$IUCNstatus,
          col = comadre_iucn$iucn_colour,
          cex = 1.1,
          frame = "none",
          bg = "transparent",
          font = 1.8,
          adj = -0.44) 

#Add tip labels for population performance colour 

tiplabels(pch = 16, col = comadre_iucn$Population_performance_colour, cex = 1.3) 

#defining the legend labels and colours 

legend_colors <- c("red", "blue")
legend_labels <- c("Decrease", "Increase")


#defining the other legend labels and colours 

iucn_status_legend <- c("green", "red", "orange", "darkgreen", "blue")
iucn_status_legend_labels <- c("LC = Least Concern", "EN = Endangered", "VU = Vulnerable", "NT = Near Threatened", "NA = Not Applicable")

#plotting these legends onto the plot 

legend("topleft", legend = legend_labels, pch = 15, col = legend_colors,
       title = "Population Performance", cex = 1, inset = c(0, 0.135))

legend("topleft", legend = iucn_status_legend_labels, pch = 15, col = iucn_status_legend,
       title = "IUCN status", cex = 1, text.col = iucn_status_legend, pt.bg = "transparent")





dev.off()



```


```{r}
#rewriting the tree code 

scaled_tree <- pruned_tree

scalig_factor <- 10 
scaled_tree$edge.length <- scaled_tree$edge.length * scaling_factor

png("phylogeny_original_rewritten.png", width = 1400, height = 1200)

plot(scaled_tree, type = "phylogram", label.offset = 0.035, cex =)

tiplabels(text = comadre_iucn$IUCNstatus,
          col = comadre_iucn$iucn_colour,
          cex = 1,1,
          frame = "none",
          bg = "transparent",
          font = 1.8,
          adj = -0.44)

tiplabels(pch = 16, col = comadre_iucn$Population_per)




```


```{r}
head(comadre_iucn)

```


Example on how to do this from website: 

```{r}
data(pruned_tree)
pruned_tree$tip.label
comadre_iucn$IUCNstatus

iucn <- setNames(pruned_tree$tip.label, c("VU", "LC", "EN", "VU", "EN", "LC", "LC", "LC", "LC", "NA", "NA", "NA", "NA", "VU", "LC", "VU", "LC", "LC", "LC", "LC", "VU", "EN", "VU"))

lambda <- setNames(pruned_tree$tip.label, c("Increase", "Increase", "Increase", "Increase", "Decline", "Decline", "Increase", "Decline", "Decline", "Decline", "Decline", "Decline", "Increase", "Increase", "Decline", "Increase", "Increase", "Decline", "Increase", "Decline", "Increase", "Increase", "Increase"))

plotTree(pruned_tree, ftype= "i")

pp <- get("pruned_tree")
pp$x.lim
pruned_tree$xlim
pp$y.lim

# Manually set the x-axis limits
custom_xlim <- c(0, 507)  # Replace minimum_value and maximum_value with your desired limits
custom_ylim <- (c(1, 26)



# Further code for customizing the plot...

        


```

```{r}

## graph the tree, updating xlim & ylim
plotTree(pruned_tree, ftype = "off",
         xlim = c(0, 507),
         ylim = c(1, 26)


plotTree(pruned_tree, ftype="off")
## pull the last plotted phylo info
pp<-get("pruned_tree")
## compute the string width in user units of our
## labels
sw<-sapply(pruned_tree$tip.label,strwidth,font=3)
## right align & re-graph our labels (this just 
## looks nicer)
par(lend=1)
for(i in 1:Ntip(pruned_tree)){
  text(x=pp$xx[i]+1.05*max(sw),y=pp$yy[i],
    pruned_tree$tip.label[i],cex=0.9,font=3,
    pos=2)
  segments(pp$xx[i],pp$yy[i],pp$xx[i]+max(sw)-sw[i],
    pp$yy[i],lty="dotted")
}
## sort our lambda values & discretize them as 
## > 1 (increasing) or < 1 (decreasing)
lambda<-lambda[pruned_tree$tip.label]
foo<-function(x) if(x>1) "white" else "black"
lam_col<-sapply(lambda,foo)
## graph the levels using points (this could 
## also be done more scientifically with e.g.,
## plotrix::draw.circle)
## the specific coordinates might need adjustment
points(pp$xx[1:Ntip(pruned_tree)]+
    1.05*max(sw)+0.02*max(nodeHeights(pruned_tree)),
  pp$yy[1:Ntip(pruned_tree)],pch=21,bg=lam_col,
  cex=2.2)
## now add IUCN status as text. Once again, the 
## font size & offset might need adjustment 
## depending on the case
text(pp$xx[1:Ntip(pruned_tree)]+
    1.05*max(sw)+0.08*max(nodeHeights(pruned_tree)),
  pp$yy[1:Ntip(pruned_tree)],
  iucn[pruned_tree$tip.label])
## finall, column headers & legend
text(pp$xx[1:Ntip(pruned_tree)]+
    max(sw)+0.01*max(nodeHeights(pruned_tree)),
  max(pp$yy)+0.75,expression(paste(lambda," (growth)")),
  srt=80,pos=4)
text(pp$xx[1:Ntip(pruned_tree)]+
    max(sw)+0.07*max(nodeHeights(pruned_tree)),
  max(pp$yy)+0.75,"IUCN status",srt=80,
  pos=4)
legend("topleft",c("decreasing","increasing"),pch=21,
  pt.bg=c("black","white"),pt.cex=2,bty="n",inset=0.05)
```

```{r}

plotTree(pruned_tree, ftype="off")
## pull the last plotted phylo info
pp <- pruned_tree
## compute the string width in user units of our
## labels
sw <- sapply(pruned_tree$tip.label, strwidth, font = 3)
## right align & re-graph our labels (this just 
## looks nicer)
par(lend=1)
for(i in 1:Ntip(pruned_tree)){
  # Manually define x and y coordinates
  x_coord <- 10  # Example x coordinate
  y_coord <- 5   # Example y coordinate
  
  text(x = x_coord, y = y_coord,
       labels = pruned_tree$tip.label[i],
       cex = 0.9, font = 3, pos = 2)
  
  # Define the starting and ending points for the dotted line
  start_x <- pp$xx[i]
  end_x <- pp$xx[i] + max(sw) - sw[i]
  y <- pp$yy[i]
  
  # Draw the dotted line
  segments(x0 = start_x, y0 = y, x1 = end_x, y1 = y, lty = "dotted")
}


## sort our lambda values & discretize them as 
## > 1 (increasing) or < 1 (decreasing)
lambda <- lambda[pruned_tree$tip.label]
foo <- function(x) if(x>1) "white" else "black"
lam_col <- sapply(lambda, foo)
## graph the levels using points (this could 
## also be done more scientifically with e.g.,
## plotrix::draw.circle)
## the specific coordinates might need adjustment
points(pp$xx[1:Ntip(pruned_tree)]+
    1.05*max(sw)+0.02*max(nodeHeights(pruned_tree)),
  pp$yy[1:Ntip(pruned_tree)], pch=21, bg=lam_col,
  cex=2.2)
## now add IUCN status as text. Once again, the 
## font size & offset might need adjustment 
## depending on the case
text(pp$xx[1:Ntip(pruned_tree)]+
    1.05*max(sw)+0.08*max(nodeHeights(pruned_tree)),
  pp$yy[1:Ntip(pruned_tree)],
  iucn[pruned_tree$tip.label])
## finall, column headers & legend
text(pp$xx[1:Ntip(pruned_tree)]+
    max(sw)+0.01*max(nodeHeights(pruned_tree)),
  max(pp$yy)+0.75, expression(paste(lambda," (growth)")),
  srt=80, pos=4)
text(pp$xx[1:Ntip(pruned_tree)]+
    max(sw)+0.07*max(nodeHeights(pruned_tree)),
  max(pp$yy)+0.75, "IUCN status", srt=80,
  pos=4)
legend("topleft", c("decreasing", "increasing"), pch=21,
  pt.bg=c("black", "white"), pt.cex=2, bty="n", inset=0.05)

```

Another way of plotting the tree: 

```{r}
x <- as.matrix(pruned_tree, row.names=1)[,1] #converts the pruned_tree into a matrix format with row names set to tip labels of the phylogenetic tree and extracts the first column of the matrix. Resulting x variable contains distances from root to tips of the tree

dotTree(pruned_tree,x,length=10,ftype="i") #dotTree function used to generate a dot representation of the phylogenetic tree

# Combine IUCN status and Population_performance_colour into a single string
label_text <- paste(comadre_iucn$IUCNstatus, comadre_iucn$Population_performance_colour, sep = ": ")

# Plot the dot representation of the tree with additional labels
dotTree(pruned_tree, x, length = 10, ftype = "i", tip.labels = label_text)


```

```{r}

# Create a data frame containing tip labels and their associated traits
tip_data <- data.frame(
  tip.label = pruned_tree$tip.label,
  IUCN_status = comadre_iucn$IUCNstatus,
  Population_performance_colour = comadre_iucn$Population_performance_colour
)

# Combine information into a single label
tip_data$label_text <- paste(tip_data$IUCN_status, tip_data$Population_performance_colour, sep = ": ")

# Plot the dot representation of the tree with custom tip labels
dotTree(pruned_tree, x, length = 10, ftype = "i", 
         nodelabels = tip_data$label_text)


```

One more try using a different approach 
```{r}
library(phytools)
pruned_tree
new_pruned_tree <-as.phylo(pruned_tree)
new_pruned_tree
iucn<-setNames(comadre_iucn$IUCNstatus,rownames(comadre_iucn))
iucn

to.matrix(iucn, levels(iucn))
```







